(* ============================================================================
   EBNF Grammar for Poem File Format (.poem)

   This grammar defines the structure of poem files used in the poems system.

   Notation:
   - Non-terminals are written in lowercase with underscores
   - Terminals are written in double quotes or defined as character patterns
   - (* ... *) denotes comments
   - [ ... ] denotes optional elements
   - { ... } denotes zero or more repetitions
   - ( ... ) denotes grouping
   - | denotes alternation
   - ? denotes any single character
   ============================================================================ *)

(* ============================================================================
   TOP-LEVEL STRUCTURE
   ============================================================================ *)

poem_file = header,
            blank_lines,
            versions_section,
            [ blank_lines,
              end_of_poem_marker,
              [ blank_lines,
                audio_section,
                [ blank_lines,
                  end_of_audio_marker,
                  [ blank_lines,
                    postscript_section,
                    [ blank_lines,
                      end_of_postscript_marker,
                      [ blank_lines,
                        analysis_section,
                        [ blank_lines,
                          end_of_file_marker,
                          blank_lines,
                          [ ignored_content ] ] ] ] ] ] ] ] ;

(* ============================================================================
   HEADER SECTION
   ============================================================================ *)

header = title_line,
         newline,
         [ author_line, newline ],
         date_line,
         newline ;

title_line = text_content ;

author_line = text_content ;

date_line = year, "-", month, "-", day ;

year = digit, digit, digit, digit ;

month = ("0", digit) | ("1", ("0" | "1" | "2")) ;

day = (("0" | "1" | "2"), digit) | ("3", ("0" | "1")) ;

(* ============================================================================
   VERSIONS SECTION
   ============================================================================ *)

versions_section = version, { [ blank_lines, version_divider ], blank_lines, version } ;

version = [ blank_lines, version_label, blank_lines ],
          segments ;

version_label = "{{", whitespace, label_text, whitespace, "}}" ;

segments = segment, { blank_lines, segment } ;

segment = [ segment_label, blank_lines ],
          segment_content ;

segment_label = "{", label_text, "}" ;

segment_content = content_line, { newline, content_line } ;

content_line = [ leading_whitespace ], text_with_markup ;

(* ============================================================================
   AUDIO SECTION
   ============================================================================ *)

audio_section = { audiomack_line | suno_line, newline } ;

audiomack_line = "Audiomack" ;

suno_line = "Suno:", whitespace, url_path ;

url_path = { url_char } ;

url_char = letter | digit | "/" | "-" | "_" | "." | "~" | ":" | "@" | "!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" ;

(* ============================================================================
   POSTSCRIPT SECTION
   ============================================================================ *)

postscript_section = [ postscript_note, { [ blank_lines, postscript_divider ], blank_lines, postscript_note } ] ;

postscript_note = [ postscript_label, blank_lines ],
                  postscript_content,
                  { blank_lines, literal_block, blank_lines } ;

postscript_label = "{", label_text, "}" ;

postscript_content = paragraph, { blank_lines, paragraph } ;

paragraph = text_with_markup, { single_newline, text_with_markup } ;

literal_block = literal_block_start,
                newline,
                { literal_block_line },
                literal_block_end ;

literal_block_start = "<<<" ;

literal_block_end = ">>>" ;

literal_block_line = literal_content, newline ;

literal_content = { ? any character except newline ? } ;

(* ============================================================================
   ANALYSIS SECTION
   ============================================================================ *)

analysis_section = [ synopsis_section, blank_lines, full_section ]
                 | [ full_section ] ;

synopsis_section = synopsis_label,
                   blank_lines,
                   analysis_content ;

synopsis_label = "{Synopsis}" ;

full_section = full_label,
               blank_lines,
               analysis_content ;

full_label = "{Full}" ;

analysis_content = analysis_block, { blank_lines, analysis_block } ;

analysis_block = heading | paragraph ;

heading = heading_h3 | heading_h4 | heading_h5 ;

heading_h3 = "#", whitespace, text_with_markup ;

heading_h4 = "##", whitespace, text_with_markup ;

heading_h5 = "###", whitespace, text_with_markup ;

(* ============================================================================
   COMMENT BLOCKS
   ============================================================================ *)

comment_block = comment_start,
                { comment_line },
                comment_end ;

comment_start = "<<#", { ? any character except newline ? }, newline ;

comment_end = "#>>", { ? any character except newline ? }, newline ;

comment_line = { ? any character except newline ? }, newline ;

(* Note: Comment blocks can appear anywhere in the file and are completely
   ignored during parsing. They do not contribute to the output. *)

(* ============================================================================
   VARIABLES
   ============================================================================ *)

variable_definition = single_line_variable | multi_line_variable ;

single_line_variable = single_line_var_start,
                       variable_name,
                       single_line_var_equals,
                       variable_value ;

single_line_var_start = "={" ;

single_line_var_equals = "}=" ;

multi_line_variable = multi_line_var_start,
                      variable_name,
                      multi_line_var_open,
                      { ? any character except newline ? },
                      newline,
                      multi_line_var_content,
                      multi_line_var_close,
                      { ? any character except newline ? },
                      newline ;

multi_line_var_start = "={" ;

multi_line_var_open = "}<<=" ;

multi_line_var_close = "=>>" ;

multi_line_var_content = { multi_line_var_line } ;

multi_line_var_line = { ? any character except newline ? }, newline ;

variable_name = ( letter | digit ), { variable_name_char } ;

variable_name_char = ? any character except "{", "}", "$", "<", ">" and space at end ? ;

variable_value = { ? any character except newline ? } ;

variable_substitution = "${", variable_name, "}" ;

(* Note: Variable definitions must be anchored to the start of a line.
   Variables are file-scoped and processed before markup conversion.
   Variable names must start with a letter or digit and cannot contain
   {, }, $, <, > characters, and cannot end with a space.
   See semantic constraints for complete variable behaviour rules. *)

(* ============================================================================
   MARKUP SYSTEM
   ============================================================================ *)

text_with_markup = { markup_element } ;

markup_element = escaped_char
               | emphasis
               | strong
               | strikethrough
               | link
               | smart_single_quote
               | smart_double_quote
               | em_dash
               | en_dash
               | ampersand
               | apostrophe
               | variable_substitution
               | plain_char ;

escaped_char = "\", ( "_" | "*" | "~" | "[" | "`" | '"' | "&" | "'" | "-" | "<" | ">" | "=" | "$" | "\" ) ;

emphasis = "_", markup_content, "_" ;

strong = "*", markup_content, "*" ;

strikethrough = "~", markup_content, "~" ;

link = "[", link_text, "|", link_url, "]" ;

link_text = markup_content ;

link_url = { url_char } ;

markup_content = { markup_element } ;

smart_single_quote = "`", text_content, "`" ;

smart_double_quote = '"', text_content, '"' ;

em_dash = "---" ;

en_dash = "--" ;

ampersand = "&" ;

apostrophe = "'" ;

plain_char = ? any character except markup special characters ? ;

(* Note: Markup pairs (emphasis, strong, strikethrough, quotes) match across
   lines within a paragraph but not across paragraph boundaries. Unmatched
   pairs are not converted. Markup can be nested. *)

(* ============================================================================
   DIVIDERS AND MARKERS
   ============================================================================ *)

version_divider = "----" ;

postscript_divider = "----" ;

end_of_poem_marker = "====" ;

end_of_audio_marker = "====" ;

end_of_postscript_marker = "====" ;

end_of_file_marker = "====" ;

(* Note: All dividers and markers must be anchored to the start of a line *)

(* ============================================================================
   IGNORED CONTENT
   ============================================================================ *)

ignored_content = { ignored_line } ;

ignored_line = { ? any character except newline ? }, newline ;

(* Note: Any content after the final end_of_file_marker is ignored *)

(* ============================================================================
   BASIC ELEMENTS
   ============================================================================ *)

label_text = text_content ;

text_content = { text_char } ;

text_char = letter | digit | whitespace | punctuation | symbol ;

letter = uppercase | lowercase ;

uppercase = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" |
            "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

lowercase = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" |
            "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

punctuation = "." | "," | ";" | ":" | "!" | "?" | "'" | '"' | "(" | ")" | "[" | "]" | "{" | "}" | "-" | "/" ;

symbol = "@" | "#" | "$" | "%" | "^" | "&" | "*" | "+" | "=" | "_" | "|" | "~" | "`" | "<" | ">" ;

whitespace = " " | tab ;

tab = ? horizontal tab character (U+0009) ? ;

newline = ? line feed character (U+000A) or carriage return + line feed (U+000D U+000A) ? ;

single_newline = newline ;

blank_line = [ whitespace ], newline ;

blank_lines = { blank_line } ;

leading_whitespace = ( " " | tab ), { " " | tab } ;

(* ============================================================================
   SEMANTIC CONSTRAINTS (not expressible in pure EBNF)
   ============================================================================ *)

(*
   1. Each version must contain at least one segment

   2. If a synopsis section is present, a full section must also be present

   3. Dividers, markers, labels, and literal block delimiters must appear
      at the start of a line (column 0)

   4. Version labels and segment labels have leading and trailing whitespace
      trimmed

   5. Within postscript notes, single newlines are collapsed (not preserved);
      only paragraph breaks (blank lines) are preserved

   6. Within poem segments, all newlines and indentation are preserved

   7. Within analysis sections, single newlines within paragraphs are
      collapsed; only paragraph breaks (blank lines) are preserved

   8. Markup special character pairs (_, *, ~, `, ") match across lines
      within a paragraph but not across paragraph boundaries

   9. Unmatched markup pairs are not converted and remain as literal text

   10. Markup can be nested (e.g., `[*_text_*|url]`)

   11. Comment blocks (<<# ... #>>) can appear anywhere and are completely
       removed during parsing

   12. The author line is optional; if omitted, defaults to "Warwick Allen"

   13. Dividers (both ---- and ====) are only required if there is subsequent
       non-empty content. If the parser reaches end-of-file, all remaining
       sections are assumed to be empty.

   14. The end_of_file_marker (====) before comments is optional - only
       required if followed by ignored content (comments)

   15. Blank lines before and after dividers, markers, labels, and literal
       block delimiters have no effect on output (they are normalized)

   16. Variables can be defined anywhere in the file, except inside literal
       blocks or multi-line variable blocks

   17. Variables are file-scoped

   18. If a variable is used before it is defined, no substitution occurs;
       ${undefined} remains as literal text (parsers should emit a warning)

   19. Variables may be redefined; the old value is clobbered

   20. Variable definition lines do not appear in output and do not count
       as content lines in their containing section

   21. Variables may be nested: A variable definition may include ${...}
       references, which are substituted when the outer variable is defined.
       Nesting may be of any depth. Self-referential definitions are allowed
       (e.g., ={a}=foo then ={a}=${a}bar expands ${a} to foobar)

   22. Variables are processed for markup after substitution

   23. Variables cannot be used inside literal blocks

   24. Variable whitespace is retained: For single-line variables, everything
       after the second "=" is included. For multi-line variables, everything
       after the newline of the start tag up to before the final newline
       before the close tag is included

   25. Variables may be used inside labels (both {{...}} and {...} labels)
*)

(* ============================================================================
   END OF GRAMMAR
   ============================================================================ *)

